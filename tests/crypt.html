<html>
<head>
  <title>Encrypt/Decrypt Text</title>
  <style>
    label {
      font-weight: bold;
    }
    #log {
      border: 1px solid #000;
      padding: 10px;
      margin-top: 10px;
    }

    pre {
      border: 1px solid #000;
      padding: 10px;
      margin-top: 10px;
    }
  </style>
  <script>
    function Debug(message) {
      console.log(message);
      document.getElementById('log').innerHTML += message + '<br>';
    }
  </script>
</head>

<body>
  <h1>Encrypt/Decrypt Text</h1>

  <!-- On submit. Run either the local Encrypt or Decript javascript function-->
  <form onsubmit="return false; ">
    <fieldset>
      <label for="password">Password: </label> (<a href="https://blog.abluestar.com/other/password.html"
        target="_blank">Password Generator</a>)<br />
      <input type="password" id="password" name="password" placeholder="Enter password">

      <br /><br />
      <label for="data">Data:</label><br>
      <textarea id="data" name="text" rows="4" cols="50"></textarea><br /><br />

      <input type="submit" value="Encrypt">
      <input type="submit" value="Decript">
    </fieldset>
  </form>

  <label for="output">Output:</label><br>

  <pre id="output"></pre>

  <hr />
  <label for="log">Log:</label><br>
  <div id="log"></div>

  <script>

    // Hardcoded constants
    const ITERATIONS = 100000;
    const SALT_LENGTH = 16; // 16 bytes salt
    const IV_LENGTH = 12;   // 12 bytes IV (recommended for AES-GCM)
    const KEY_LENGTH = 256; // AES-GCM 256-bit key length

    // Encryption functions 
    // --------------------

    // Function to generate a salt
    function generateSalt() {
      return crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
    }

    // Derive a key from the user's password using PBKDF2
    async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        encoder.encode(password), // Encode the password
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );

      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: salt,
          iterations: ITERATIONS, // Fixed iterations
          hash: "SHA-256" // Fixed hashing algorithm
        },
        keyMaterial,
        { name: "AES-GCM", length: KEY_LENGTH }, // AES key for encryption/decryption
        true, // Can be exported
        ["encrypt", "decrypt"]
      );
    }

    // Encrypt a text using the password, automatically generating salt and IV
    async function encryptDataWithPassword(password, text) {
      const salt = generateSalt(); // Generate a salt
      const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH)); // Generate an IV
      const key = await deriveKey(password, salt); // Derive the key from password

      const encoder = new TextEncoder();
      const encodedText = encoder.encode(text);

      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: iv },
        key,
        encodedText
      );

      // Combine salt, IV, and ciphertext into a single Uint8Array for easy storage
      const combinedData = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
      combinedData.set(salt);
      combinedData.set(iv, salt.length);
      combinedData.set(new Uint8Array(ciphertext), salt.length + iv.length);

      // Convert to Base64 for storage or transmission
      return btoa(String.fromCharCode(...combinedData));
    }

    // Decrypt the data using the password
    async function decryptDataWithPassword(password, encryptedData) {
      // Decode the Base64-encoded data
      const combinedData = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));

      // Extract salt, IV, and ciphertext from the combined data
      const salt = combinedData.slice(0, SALT_LENGTH);
      const iv = combinedData.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
      const ciphertext = combinedData.slice(SALT_LENGTH + IV_LENGTH);

      // Derive the key using the same password and salt
      const key = await deriveKey(password, salt);

      // Decrypt the ciphertext
      const decryptedData = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: iv },
        key,
        ciphertext
      );

      const decoder = new TextDecoder();
      return decoder.decode(decryptedData); // Return the decrypted text
    }

    // UI functions
    // ------------

    // Encrypt the text
    async function Encrypt(text, password) {
      Debug('Encrypting text');
      Debug('Text: ' + text);
      Debug('Password: ****');

      const ciphertext = await encryptDataWithPassword(password, text);
      Debug("Ciphertext:", ciphertext);
      return ciphertext;
    }

    // Decrypt the text
    async function Decrypt(ciphertext, password) {
      Debug('Decrypting text');
      Debug('Ciphertext: ' + ciphertext);
      Debug('Password: ****');

      const decryptedText = await decryptDataWithPassword(password, ciphertext);
      Debug("Decrypted Text:" + decryptedText); // Should output: "This is a secret message!"
      return decryptedText;
    }

    // On submit, run either the Encrypt or Decrypt function
    document.querySelector('form').addEventListener('submit', function (event) {
      var password = document.getElementById('password').value;
      var text = document.getElementById('data').value;

      // Clear the output
      document.getElementById('output').innerText = '';

      try {
        if (event.submitter.value == 'Encrypt') {

          Encrypt(text, password).then(function (ciphertext) {
            document.getElementById('output').innerText = ciphertext;
          });
        } else {
          Decrypt(text, password).then(function (decryptedText) {
            document.getElementById('output').innerText = decryptedText;
          });
        }
      } catch (error) {
        Debug('Error: ' + error);
      }
    });

  </script>
</body>

</html>